#pragma kernel CSMain
#define MAX_MEMORY_SIZE 16
#define MAX_OPERATIONS_SIZE 256
#define MAX_DEPTH_SAMPLES 2048
#define MAX_EXPLORATION_SAMPLES 20

float3 camRight;
float3 camUp;

float nearSize;
float farSize;

float3 nearStart;
float3 farStart;

float width;
float height;
float region;
int depth;

float depthExplorationMult;
float normalPlaneMultiplier;
float normalExplorationMultiplier;

bool clampToRegion;
float2 regionX;
float2 regionY;
float2 regionZ;
float3 regionScale;
float3 regionCenter;

int variable;
int criterion;
float threshold;
float difference;

int explorationSamples;

RWBuffer<float> memoryBuffer;
Buffer<int> operationsBuffer;
int operationsSize;
int maxOperatorIndex;
int maxMemoryIndex;
int resultIndex;

RWTexture2D<float4> DepthTex;
RWTexture2D<float4> NormalTex;

#define GREATER_THAN 0
#define LESS_THAN 1
#define MIN_DIFFERENCE 2
bool Interpretate(float3 pos, float eval)
{
	int posCoord = clamp(variable, 0, 2);
    float useThreshold = variable > 2;
	float v = lerp(pos[posCoord], threshold, useThreshold);
	switch (criterion)
	{
		case GREATER_THAN:
			return eval >= v;
		case LESS_THAN:
			return eval <= v;
		case MIN_DIFFERENCE:
			return abs(eval - v) < difference;
		default:
			return 0.0f;
	}
}

#define FUNC_COS 0
#define FUNC_SIN 1
#define FUNC_ABS 2
float SolveSubFunction(int op, float v0, float v1, float v2)
{
    switch (op)
    {
		case FUNC_COS:
            return cos(v0);
		case FUNC_SIN:
            return sin(v0);
		case FUNC_ABS:
            return abs(v0);
		default:
            return 0.0f;
	}
}

#define SUBTRACT 0
#define ADD 1
#define PRODUCT 2
#define DIVISION 3
#define POWER 4
float SolveOperator(int op, float v0, float v1)
{
    switch (op) {
		case SUBTRACT:
			return v0 - v1;
		case ADD:
			return v0 + v1;
		case PRODUCT:
			return v0 * v1;
		case DIVISION:
			return v0 / v1;
		case POWER:
            uint v1Int = v1;
            bool v1IsEven = v1Int % 2 == 0;
            bool v0IsPositive = v0 >= 0;
            float p = pow(abs(v0), v1Int);
            p = p * (v0IsPositive || v1IsEven) - p * (!v0IsPositive && !v1IsEven);
            return p;
	    default:
            return 0.0f;
	}
}

bool IsMass(float3 pos, half mem[MAX_MEMORY_SIZE])
{
    
    bool outOfRegion = pos.x < regionX.x || pos.x > regionX.y ||
        pos.y < regionY.x || pos.y > regionY.y ||
        pos.z < regionZ.x || pos.z > regionZ.y;

    outOfRegion = outOfRegion && clampToRegion;

    mem[0] = 0;
    mem[1] = pos.x;
    mem[2] = pos.y;
    mem[3] = pos.z;
    
    int i = 0;
    int positive;

    int finalOperationsSize = min(operationsSize, MAX_OPERATIONS_SIZE);
    while(i < finalOperationsSize){
        int op = operationsBuffer[i];

        positive = operationsBuffer[i+1] > 0;
        float v0 = mem[abs(operationsBuffer[i+1])];
        v0 = v0 * positive - v0 * (1 - positive);
        
        positive = operationsBuffer[i+2] > 0;
        float v1 = mem[abs(operationsBuffer[i+2])];
        v1 = v1 * positive - v1 * (1 - positive);

        bool isSubfunc = op > maxOperatorIndex - 1;
        positive = operationsBuffer[i + 3] > 0;
        float v2 = mem[abs(operationsBuffer[i + 3])];
        v2 = v2 * positive - v2 * (1 - positive);

        float resultSubFunc = SolveSubFunction(op - maxOperatorIndex, v0, v1, v2);
        float resultOp = SolveOperator(op, v0, v1);

        float result = resultSubFunc * isSubfunc + resultOp * (1 - isSubfunc);
        i = (i + 4) * isSubfunc + (i + 3) * (1 - isSubfunc);

        int rIdx = operationsBuffer[i];
        mem[rIdx] = result;
        i++;
    }

    int absIdx = abs(resultIndex);
    positive = resultIndex > 0;
    float eval = mem[absIdx];
    eval = eval * positive - eval * (1 - positive);

    return !outOfRegion && Interpretate(pos, eval);
}

float4 ExploreDirectionDAC(float3 origin, float3 destiny, bool originInside, half mem[MAX_MEMORY_SIZE])
{

    float3 middle = destiny;
    bool reachedSurface = IsMass(destiny, mem) != originInside;

    if (reachedSurface) {
        int finalExplorationSamples = min(explorationSamples, MAX_EXPLORATION_SAMPLES);
        for (int i = 0; i < finalExplorationSamples; i++) {
            middle = lerp(origin, destiny, 0.5f);
            float mass = IsMass(middle, mem) == originInside;
            origin = middle * mass + origin * (1.0 - mass);
            destiny = middle * (1.0 - mass) + destiny * mass;
        }
    }

    return float4(middle, reachedSurface);
}

float3 CalculateNormal(float3 pos, float3 rayDir, float explorationRadius, half mem[MAX_MEMORY_SIZE])
{
    float3 right = normalize(float3(1, 1, (-rayDir.x - rayDir.y) / rayDir.z));
    float3 forward = normalize(cross(rayDir, right));

    float3 points[4] = {
        pos + right * explorationRadius * normalPlaneMultiplier,
        pos + forward * explorationRadius * normalPlaneMultiplier,
        pos - right * explorationRadius * normalPlaneMultiplier,
        pos - forward * explorationRadius * normalPlaneMultiplier
    };

    rayDir = normalize(rayDir) * explorationRadius * normalExplorationMultiplier;

    for (int i = 0; i < 4; i++) {
        bool pointInside = IsMass(points[i], mem);
        float pointInsideF = pointInside;
        float3 dir = rayDir * pointInsideF - rayDir * (1 - pointInsideF);
        float4 s = ExploreDirectionDAC(points[i], points[i] + dir, pointInside, mem);
        points[i] = normalize(s.xyz - pos);
    }

    float3 n = float3(0, 0, 0);
    for (int j = 0; j < 3; j++) {
        n += cross(points[j], points[j + 1]);
    }

    n = normalize(n);

    return n;
}

float3 TransformToRegion(float3 pos) {
    return float3(pos.x * regionScale.x, pos.z * regionScale.y, pos.y * regionScale.z) + regionCenter;
}

/*float RayCast(float3 origin, float3 destiny)
{
	bool landed = false;
	float normDepth = 0.0f;
	float3 pos = float3(0, 0, 0);
    
	int maxDepth = min(depth, MAX_DEPTH_SAMPLES);
	float maxDepthF = (float) maxDepth;
    
	for (int z = 0; z < maxDepth && !landed; z++)
	{
		normDepth = z / maxDepthF;
		pos = lerp(origin, destiny, normDepth);
		landed = IsMass(pos, mem);
	}
}*/

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	half mem[MAX_MEMORY_SIZE];
	int finalMaxMemoryIndex = min(maxMemoryIndex, MAX_MEMORY_SIZE);
	for (int i = 0; i < maxMemoryIndex; i++)
	{
		mem[i] = memoryBuffer[i];
	}
    
	float x = id.x;
	float y = id.y;
    
	float3 nearPos = nearStart + (camRight * x / width - camUp * y / height) * region * nearSize;
	float3 farPos = farStart + (camRight * x / width - camUp * y / height) * region * farSize;
	nearPos = TransformToRegion(nearPos);
	farPos = TransformToRegion(farPos);
    
	bool landed = false;
	float normDepth = 0.0f;
	float3 pos = float3(0, 0, 0);
    
	int maxDepth = min(depth, MAX_DEPTH_SAMPLES);
	float maxDepthF = (float) maxDepth;
	for (int z = 0; z < maxDepth && !landed; z++)
	{
		normDepth = z / maxDepthF;
		pos = lerp(nearPos, farPos, normDepth);
		landed = IsMass(pos, mem);
	}
    
	float3 normalColor = float3(1, 1, 1);
	bool reachedSurface = false;
    
    
	if (landed)
	{
		float3 rayDir = nearPos - farPos;
		float rayDirMag = length(rayDir);
		float rayStep = rayDirMag / depth;
		rayDir = normalize(rayDir);
    
		float4 surface = ExploreDirectionDAC(pos, pos + rayDir * rayStep * depthExplorationMult, true, mem);
		float3 dirToSurface = nearPos - surface.xyz;
		normDepth = length(dirToSurface) / rayDirMag;
		float3 normal = CalculateNormal(surface.xyz, rayDir, rayStep, mem);
		normalColor = normal.xzy * 0.5f + 0.5f;
	}
    
	float4 finalDepthColor = float4(normDepth, (float) landed, 0, 1);
	float4 finalNormalColor = float4(normalColor, 1);
    
	uint2 texCoord = uint2(id.x, height - id.y - 1);
	DepthTex[texCoord] = finalDepthColor;
	NormalTex[texCoord] = finalNormalColor;
}


