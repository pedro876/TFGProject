#pragma kernel CSMain
#define MAX_MEMORY_SIZE 256
#define MAX_OPERATIONS_SIZE 256
#define MAX_DEPTH_SAMPLES 2048
#define MAX_EXPLORATION_SAMPLES 20

float3 camRight;
float3 camUp;

float nearSize;
float farSize;

float3 nearStart;
float3 farStart;

float width;
float height;
float region;
int depth;

float depthExplorationMult;
float normalPlaneMultiplier;
float normalExplorationMultiplier;

bool clampToRegion;
float2 regionX;
float2 regionY;
float2 regionZ;
float3 regionScale;
float3 regionCenter;

int variable;
int criterion;
float threshold;
float difference;

int explorationSamples;

RWBuffer<float> memoryBuffer;
Buffer<int> operationsBuffer;
int operationsSize;
int maxOperatorIndex;
int maxMemoryIndex;
int resultIndex;

RWTexture2D<float4> DepthTex;
RWTexture2D<float4> NormalTex;

// STRUCTURES

struct Ray
{
	float3 origin;
	float3 destiny;
	float3 dir;
	float magitude;
	float step;
};

Ray MakeRay(float3 origin, float3 destiny)
{
	Ray ray;
	ray.origin = origin;
	ray.destiny = destiny;
	ray.dir = origin - destiny;
	ray.magitude = length(ray.dir);
	ray.step = ray.magitude / depth;
	ray.dir = normalize(ray.dir);
	return ray;
}

struct RayHit
{
	float normDepth;
	float3 pos;
	bool grounded;
	float3 normal;
};

RayHit MakeRayHit()
{
	RayHit hit;
	hit.grounded = false;
	hit.normDepth = 0.0f;
	hit.pos = float3(0, 0, 0);
	hit.normal = float3(1, 1, 1);
	return hit;
}

// BYTECODE RESULT INTERPRETATION

#define GREATER_THAN 0
#define LESS_THAN 1
#define MIN_DIFFERENCE 2
bool Interpretate(float3 pos, float eval)
{
	int posCoord = clamp(variable, 0, 2);
    float useThreshold = variable > 2;
	float v = lerp(pos[posCoord], threshold, useThreshold);
	switch (criterion)
	{
		case GREATER_THAN:
			return eval >= v;
		case LESS_THAN:
			return eval <= v;
		case MIN_DIFFERENCE:
			return abs(eval - v) < difference;
		default:
			return 0.0f;
	}
}

// BYTECODE OPERATIONS

#define FUNC_COS 0
#define FUNC_SIN 1
#define FUNC_ABS 2
float SolveSubFunction(int op, float v0, float v1, float v2)
{
	int subFunction = op - maxOperatorIndex;
	switch (subFunction)
	{
		case FUNC_COS:
            return cos(v0);
		case FUNC_SIN:
            return sin(v0);
		case FUNC_ABS:
            return abs(v0);
		default:
            return 0.0f;
	}
}

#define SUBTRACT 0
#define ADD 1
#define PRODUCT 2
#define DIVISION 3
#define POWER 4
float SolveOperator(int operation, float v0, float v1)
{
	switch (operation)
	{
		case SUBTRACT:
			return v0 - v1;
		case ADD:
			return v0 + v1;
		case PRODUCT:
			return v0 * v1;
		case DIVISION:
			return v0 / v1;
		case POWER:
            uint v1Int = v1;
            bool v1IsEven = v1Int % 2 == 0;
            bool v0IsPositive = v0 >= 0;
            float p = pow(abs(v0), v1Int);
            p = p * (v0IsPositive || v1IsEven) - p * (!v0IsPositive && !v1IsEven);
            return p;
	    default:
            return 0.0f;
	}
}

// BYTECODE INTERPRETATION

float ChangeSignIf(float val, bool condition)
{
	return val * (-2 * condition + 1);
}

bool IsOperationASubfunction(int operation)
{
	return operation > maxOperatorIndex - 1;
}

bool IsPositionOutOfBounds(float3 pos)
{
	bool outOfRegion = pos.x < regionX.x || pos.x > regionX.y ||
        pos.y < regionY.x || pos.y > regionY.y ||
        pos.z < regionZ.x || pos.z > regionZ.y;

	return outOfRegion && clampToRegion;
}

float SolveByteCode(float3 pos)
{
    const static int clampedMaxMemoryIndex = clamp(maxMemoryIndex, 0, MAX_MEMORY_SIZE);
    const static int clampedOperationsSize = clamp(operationsSize, 0, MAX_OPERATIONS_SIZE);
	
    half memoryLocalCopy[MAX_MEMORY_SIZE];
    for (int u = 0; u < clampedMaxMemoryIndex; u++)
    {
        memoryLocalCopy[u] = memoryBuffer[u];
    }
		
    memoryLocalCopy[0] = 0;
    memoryLocalCopy[1] = pos.x;
    memoryLocalCopy[2] = pos.y;
    memoryLocalCopy[3] = pos.z;
    
    int i = 0;
    int memoryIndex = 0;

    while (i < clampedOperationsSize)
    {
        int operation = operationsBuffer[i];

        memoryIndex = operationsBuffer[i + 1];
        float v0 = memoryLocalCopy[abs(memoryIndex)];
        v0 = ChangeSignIf(v0, memoryIndex < 0);
        
        memoryIndex = operationsBuffer[i + 2];
        float v1 = memoryLocalCopy[abs(memoryIndex)];
        v1 = ChangeSignIf(v1, memoryIndex < 0);

        float operationResult;
        if (IsOperationASubfunction(operation))
        {
            memoryIndex = operationsBuffer[i + 3];
            float v2 = memoryLocalCopy[abs(memoryIndex)];
            v2 = ChangeSignIf(v2, memoryIndex < 0);
            operationResult = SolveSubFunction(operation, v0, v1, v2);
            i += 4;
        }
        else
        {
            operationResult = SolveOperator(operation, v0, v1);
            i += 3;
        }

        int opResultIndex = operationsBuffer[i];
        memoryLocalCopy[opResultIndex] = operationResult;
        i++;
    }

    float result = memoryLocalCopy[abs(resultIndex)];
    result = ChangeSignIf(result, resultIndex < 0);

    return Interpretate(pos, result);
}

bool IsMass(float3 pos)
{
	bool outOfBounds = IsPositionOutOfBounds(pos);
	if (outOfBounds)
	{
		return false;
	}
	else
	{
        float functionResult = SolveByteCode(pos);
        return functionResult;
    }
}

// RAYTRACED EXPLORATION

float4 ExploreDirectionDAC(float3 origin, float3 destiny, bool originInside)
{
    float3 middle = destiny;
    bool reachedSurface = IsMass(destiny) != originInside;

    if (reachedSurface)
	{
        int clampedExplorationSamples = clamp(explorationSamples, 0, MAX_EXPLORATION_SAMPLES);
		for (int i = 0; i < clampedExplorationSamples; i++)
		{
            middle = lerp(origin, destiny, 0.5f);
            float mass = IsMass(middle) == originInside;
            origin = middle * mass + origin * (1.0 - mass);
            destiny = middle * (1.0 - mass) + destiny * mass;
        }
    }

    return float4(middle, reachedSurface);
}

RayHit ReachSurface(Ray ray, RayHit hit)
{
	float3 origin = hit.pos;
	float3 destiny = hit.pos + ray.dir * ray.step * depthExplorationMult;
	float4 surface = ExploreDirectionDAC(origin, destiny, true);
    
	hit.pos = surface.xyz;
	hit.normDepth = length(ray.origin - surface.xyz) / ray.magitude;
    
	return hit;
}

RayHit RayCast(Ray ray)
{
	RayHit hit = MakeRayHit();
    
	static int clampedDepth = clamp(depth, 0, MAX_DEPTH_SAMPLES);
	static float maxDepth = (float) clampedDepth;
    
	for (int z = 0; z < clampedDepth && !hit.grounded; z++)
	{
		hit.normDepth = z / maxDepth;
		hit.pos = lerp(ray.origin, ray.destiny, hit.normDepth);
		hit.grounded = IsMass(hit.pos);
	}
    
	return hit;
}

// NORMALS

float3 CalculateNormal(Ray ray, RayHit hit, float explorationRadius)
{
	float3 right = normalize(float3(1, 1, (-ray.dir.x - ray.dir.y) / ray.dir.z));
	float3 forward = normalize(cross(ray.dir, right));

	float3 points[4] =
	{
		hit.pos + right * explorationRadius * normalPlaneMultiplier,
        hit.pos + forward * explorationRadius * normalPlaneMultiplier,
        hit.pos - right * explorationRadius * normalPlaneMultiplier,
        hit.pos - forward * explorationRadius * normalPlaneMultiplier
	};
    
	float3 rayExplorationDir = normalize(ray.dir) * explorationRadius * normalExplorationMultiplier;
	for (int i = 0; i < 4; i++)
	{
		bool pointIsMass = IsMass(points[i]);
		float3 dirToSurface = lerp(-rayExplorationDir, rayExplorationDir, pointIsMass);
		float4 surface = ExploreDirectionDAC(points[i], points[i] + dirToSurface, pointIsMass);
		points[i] = normalize(surface.xyz - hit.pos);
	}

	float3 normal = float3(0, 0, 0);
	for (int j = 0; j < 3; j++)
	{
		normal += cross(points[j], points[j + 1]);
	}
	normal = normalize(normal);

	return normal;
}

// ORIGIN AND DESTINY

float3 TransformToRegion(float3 pos)
{
	return float3(pos.x * regionScale.x, pos.z * regionScale.y, pos.y * regionScale.z) + regionCenter;
}

float3 ScreenToCameraCoords(float2 screenPosition, float depth)
{
    float scale = lerp(nearSize, farSize, depth);
    return (camRight * screenPosition.x / width - camUp * screenPosition.y / height) * region * scale;
}

#define NEAR_DEPTH 0
float3 GetOriginFromScreenPos(float2 screenPosition)
{
    float3 origin = nearStart + ScreenToCameraCoords(screenPosition, NEAR_DEPTH);
	origin = TransformToRegion(origin);
	return origin;
}

#define FAR_DEPTH 1
float3 GetDestinyFromScreenPos(float2 screenPosition)
{
    float3 destiny = farStart + ScreenToCameraCoords(screenPosition, FAR_DEPTH);
	destiny = TransformToRegion(destiny);
	return destiny;
}

Ray CreateRayForId(uint3 id)
{
    float2 screenPosition = float2(id.x, id.y);
    float3 origin = GetOriginFromScreenPos(screenPosition);
    float3 destiny = GetDestinyFromScreenPos(screenPosition);
    Ray ray = MakeRay(origin, destiny);
    return ray;
}

// COLOR FORMAT

float4 FormatDepthColorFromHit(RayHit hit)
{
	return float4(hit.normDepth, (float) hit.grounded, 0, 1);
}

float4 FormatNormalColorFromHit(RayHit hit)
{
	return float4(hit.normal.xzy*0.5f+0.5f, 1);
}

// MAIN

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    Ray ray = CreateRayForId(id);
	RayHit hit = RayCast(ray);
    
	if (hit.grounded)
	{
		hit = ReachSurface(ray, hit);
		hit.normal = CalculateNormal(ray, hit, ray.step);
	}
    
	uint2 texCoord = uint2(id.x, height - id.y - 1);
	DepthTex[texCoord] = FormatDepthColorFromHit(hit);
	NormalTex[texCoord] = FormatNormalColorFromHit(hit);
}


