#define AUX_VAL_RND 43758.54
#define AUX_VEC_X 12.9898
#define AUX_VEC_Y 78.233
#define AUX_VEC_Z 43.7689
#define STREAM_SIZE 1024;

//int streamSize;
Buffer<float> randomStream;

float Random(float x)
{
    int index = abs(sin(x)) * 5000;
    index = index % STREAM_SIZE;
    return randomStream[index];
}

float Random(float x, float y)
{
    return Random((x * AUX_VEC_X + y * AUX_VEC_Y) * AUX_VAL_RND);
}

float Random(float x, float y, float z)
{
    return Random((x * AUX_VEC_X + y * AUX_VEC_Y + z * AUX_VEC_Z) * AUX_VAL_RND);
}

float Voxel(float x, float y, float z)
{
    return Random(round(x), round(y), round(z));
}

float Perlin(float x)
{
    x += 1000;
    float fract = frac(x);
    x = floor(x);
    return smoothstep(Random(x), Random(x + 1f), fract);
}

float Perlin(float x, float y)
{
    x += 1000;
    y += 1000;
    float xFract = frac(x);
    float yFract = frac(y);

    float x0 = floor(x);
    float y0 = floor(y);
    float x1 = x0 + 1;
    float y1 = y0 + 1;

    float c00 = Random(x0, y0);
    float c10 = Random(x1, y0);
    float c01 = Random(x0, y1);
    float c11 = Random(x1, y1);

    float s00_10 = smoothstep(c00, c10, xFract);
    float s01_11 = smoothstep(c01, c11, xFract);

    float perlin2 = smoothstep(s00_10, s01_11, yFract);

    return perlin2;
}

float Perlin(float x, float y, float z)
{
    x += 1000;
    y += 1000;
    z += 1000;
    float xFract = frac(x);
    float yFract = frac(y);
    float zFract = frac(z);

    float x0 = floor(x);
    float y0 = floor(y);
    float z0 = floor(z);
    float x1 = x0 + 1;
    float y1 = y0 + 1;
    float z1 = z0 + 1;

    float c000 = Random(x0, y0, z0);
    float c100 = Random(x1, y0, z0);
    float c010 = Random(x0, y1, z0);
    float c110 = Random(x1, y1, z0);

    float c001 = Random(x0, y0, z1);
    float c101 = Random(x1, y0, z1);
    float c011 = Random(x0, y1, z1);
    float c111 = Random(x1, y1, z1);

    float s000_100 = smoothstep(c000, c100, xFract);
    float s010_110 = smoothstep(c010, c110, xFract);

    float perlinZ0 = smoothstep(s000_100, s010_110, yFract);

    float s001_101 = smoothstep(c001, c101, xFract);
    float s011_111 = smoothstep(c011, c111, xFract);

    float perlinZ1 = smoothstep(s001_101, s011_111, yFract);

    float perlin3 = smoothstep(perlinZ0, perlinZ1, zFract);

    return perlin3;
}
